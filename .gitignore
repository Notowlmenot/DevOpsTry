

Понимаю! Цель — дать вам основу для самостоятельного изучения и экспериментов. Вот код двух простых микросервисов на Golang, без привязки к конкретным DevOps инструментам, но с указанием, какие DevOps практики и инструменты можно к ним применить.
Часть 1: Код Микросервисов на Golang
1. Пользовательский сервис (user-service)

Файл: user_service/main.go
go

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"sync"
)

// User представляет структуру данных пользователя
type User struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
	Email string `json:"email"` // Добавим еще одно поле
}

var (
	// users - наше "хранилище" пользователей в памяти
	users = map[int]User{}
	// nextID - генератор ID для новых пользователей
	nextID = 1
	// mu - мьютекс для защиты доступа к общим данным (users, nextID)
	mu sync.Mutex
)

// handlerUsers обрабатывает запросы к /users
func handlerUsers(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		// Получение списка всех пользователей
		mu.Lock()
		userList := make([]User, 0, len(users))
		for _, user := range users {
			userList = append(userList, user)
		}
		mu.Unlock()

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(userList)

	case http.MethodPost:
		// Создание нового пользователя
		var newUser User
		err := json.NewDecoder(r.Body).Decode(&newUser)
		if err != nil {
			http.Error(w, "Invalid request payload", http.StatusBadRequest)
			return
		}

		mu.Lock()
		newUser.ID = nextID
		users[newUser.ID] = newUser
		nextID++
		mu.Unlock()

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(newUser)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// handlerUser обрабатывает запросы к /users/{id}
func handlerUser(w http.ResponseWriter, r *http.Request) {
	// Извлекаем ID из URL
	idStr := r.URL.Path[len("/users/"):]
	id, err := strconv.Atoi(idStr)
	if err != nil {
		http.Error(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	switch r.Method {
	case http.MethodGet:
		// Получение конкретного пользователя по ID
		mu.Lock()
		user, ok := users[id]
		mu.Unlock()

		if !ok {
			http.Error(w, "User not found", http.StatusNotFound)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(user)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func main() {
	// Имитация начальных данных (для примера)
	mu.Lock()
	users[nextID] = User{ID: nextID, Name: "Admin", Email: "admin@example.com"}
	nextID++
	users[nextID] = User{ID: nextID, Name: "Guest", Email: "guest@example.com"}
	nextID++
	mu.Unlock()

	// Регистрация обработчиков HTTP
	http.HandleFunc("/users", handlerUsers)
	http.HandleFunc("/users/", handlerUser)

	// Запуск HTTP-сервера
	port := "8081"
	fmt.Printf("User Service listening on :%s\n", port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}

2. Сервис заказов (order-service)

Файл: order_service/main.go
go

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"sync"
	"os" // Для чтения переменных окружения
)

// Order представляет структуру данных заказа
type Order struct {
	ID        int    `json:"id"`
	UserID    int    `json:"user_id"`
	ProductName string `json:"product_name"`
	Quantity  int    `json:"quantity"` // Добавим еще одно поле
}

var (
	// orders - наше "хранилище" заказов в памяти
	orders = map[int]Order{}
	// nextOrderID - генератор ID для новых заказов
	nextOrderID = 1
	// mu - мьютекс для защиты доступа к общим данным (orders, nextOrderID)
	mu sync.Mutex

	// userServiceURL - URL другого сервиса, который мы будем вызывать
	userServiceURL string
)

// init выполняется до main() и используется для инициализации глобальных переменных
func init() {
	// Читаем URL UserService из переменной окружения.
	// Это позволяет легко менять адрес при развертывании.
	userServiceURL = os.Getenv("USER_SERVICE_URL")
	if userServiceURL == "" {
		// Если переменная не установлена, используем значение по умолчанию
		// для локальной разработки.
		userServiceURL = "http://localhost:8081" // Дефолтное значение, если не задано
		log.Printf("USER_SERVICE_URL not set, using default: %s", userServiceURL)
	}
}

// isUserExists проверяет, существует ли пользователь, обращаясь к UserService
func isUserExists(userID int) bool {
	// В реальном приложении здесь был бы HTTP-запрос к UserService
	// Для примера, мы делаем реальный HTTP-запрос.
	client := &http.Client{} // Простой HTTP-клиент

	// Формируем URL для запроса к UserService
	requestURL := fmt.Sprintf("%s/users/%d", userServiceURL, userID)

	// Создаем GET-запрос
	req, err := http.NewRequest("GET", requestURL, nil)
	if err != nil {
		log.Printf("Error creating request to user-service: %v", err)
		return false // Считаем, что пользователя нет, если произошла ошибка
	}

	// Выполняем запрос
	resp, err := client.Do(req)
	if err != nil {
		log.Printf("Error contacting user-service at %s: %v", requestURL, err)
		return false // Считаем, что пользователя нет, если произошла ошибка сети
	}
	defer resp.Body.Close() // Важно закрыть тело ответа

	// Проверяем статус код ответа
	if resp.StatusCode == http.StatusOK {
		// Если пользователь найден (код 200 OK), возвращаем true
		return true
	} else if resp.StatusCode == http.StatusNotFound {
		// Если пользователь не найден (код 404 Not Found), возвращаем false
		return false
	} else {
		// Для других кодов ошибок также считаем, что пользователя нет
		log.Printf("Unexpected status code from user-service: %d", resp.StatusCode)
		return false
	}
}

// handlerOrders обрабатывает запросы к /orders
func handlerOrders(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		// Получение списка всех заказов
		mu.Lock()
		orderList := make([]Order, 0, len(orders))
		for _, order := range orders {
			orderList = append(orderList, order)
		}
		mu.Unlock()

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(orderList)

	case http.MethodPost:
		// Создание нового заказа
		var newOrder Order
		err := json.NewDecoder(r.Body).Decode(&newOrder)
		if err != nil {
			http.Error(w, "Invalid request payload", http.StatusBadRequest)
			return
		}

		// Проверяем, существует ли пользователь, прежде чем создать заказ
		if !isUserExists(newOrder.UserID) {
			// Если пользователя нет, возвращаем ошибку 400 Bad Request
			http.Error(w, fmt.Sprintf("User with ID %d not found", newOrder.UserID), http.StatusBadRequest)
			return
		}

		mu.Lock()
		newOrder.ID = nextOrderID
		orders[newOrder.ID] = newOrder
		nextOrderID++
		mu.Unlock()

		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(newOrder)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

// handlerUserOrders обрабатывает запросы к /orders/user/{user_id}
func handlerUserOrders(w http.ResponseWriter, r *http.Request) {
	// Извлекаем User ID из URL
	idStr := r.URL.Path[len("/orders/user/"):]
	userID, err := strconv.Atoi(idStr)
	if err != nil {
		http.Error(w, "Invalid user ID", http.StatusBadRequest)
		return
	}

	switch r.Method {
	case http.MethodGet:
		// Получение заказов конкретного пользователя
		mu.Lock()
		userOrderList := []Order{}
		for _, order := range orders {
			if order.UserID == userID {
				userOrderList = append(userOrderList, order)
			}
		}
		mu.Unlock()

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(userOrderList)

	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func main() {
	// Регистрация обработчиков HTTP
	http.HandleFunc("/orders", handlerOrders)
	http.HandleFunc("/orders/user/", handlerUserOrders)

	// Запуск HTTP-сервера
	port := "8082"
	fmt.Printf("Order Service listening on :%s\n", port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}

Часть 2: Пункты для внедрения DevOps инструментов

Вот список praktik и инструментов DevOps, которые можно применить к данному коду. Для каждого пункта я опишу, какую задачу он решает, но предоставлю только концепцию, а не готовое решение.

    Контейнеризация (Docker)
        Что это: Изоляция приложений и их зависимостей в легковесные, переносимые контейнеры.
        Для чего: Обеспечение согласованности среды между разработкой, тестированием и продакшеном. Упрощение развертывания.
        Применение к коду: Создать Dockerfile для каждого микросервиса (user-service, order-service). В Dockerfile описывается, как собрать бинарник Golang приложения и упаковать его в минимальный образ (например, Alpine Linux).
        Примеры задач:
            Собрать бинарник Golang в Docker образе.
            Указать, какой порт должен слушать контейнер.
            Определить команду для запуска приложения внутри контейнера.

    Оркестрация контейнеров (Docker Compose)
        Что это: Инструмент для определения и запуска многоконтейнерных Docker приложений.
        Для чего: Управление запуском, остановкой и связями между несколькими микросервисами.
        Применение к коду: Создать файл docker-compose.yml, который описывает:
            Какие сервисы (контейнеры) есть в приложении.
            Как они собираются (ссылка на Dockerfile).
            Какие порты пробрасываются.
            Как сервисы будут взаимодействовать друг с другом (например, order-service должен знать, где найти user-service).
            Зависимости между сервисами (чтобы order-service запускался после user-service).
        Примеры задач:
            Запустить оба сервиса одной командой.
            Настроить сеть, чтобы сервисы могли общаться по их именам.
            Передать в order-service URL user-service через переменные окружения.

    CI/CD (Continuous Integration / Continuous Delivery/Deployment)
        Что это: Автоматизация процессов сборки, тестирования и развертывания программного обеспечения.
        Для чего: Ускорение цикла разработки, снижение количества ошибок, повышение надежности.
        Применение к коду: Интегрировать автоматизированные пайплайны, которые будут запускаться при изменениях в коде.
        Примеры задач (на этапах пайплайна):
            CI (Integration):
                Сборка Docker образов (make build-all-services).
                Запуск модульных тестов (go test ./... внутри каждого сервиса).
                Запуск интеграционных тестов (например, скрипт, который запускает docker-compose up, отправляет запросы и проверяет ответы, а затем docker-compose down).
                Сканирование кода на уязвимости (например, с помощью SonarQube или Trivy).
            CD (Delivery/Deployment):
                Публикация собранных Docker образов в реестр (Docker Hub, GitLab Registry, GCR).
                Автоматическое развертывание новой версии в тестовое, staging или продакшен окружение.

    Логирование (Centralized Logging)
        Что это: Сбор, агрегация и анализ логов со всех экземпляров приложения и сервисов в одном месте.
        Для чего: Быстрое обнаружение и диагностика проблем, анализ поведения системы.
        Применение к коду: Использовать более продвинутые библиотеки логирования в Golang (например, logrus или zap) вместо стандартного log. Настроить отправку логов в централизованную систему (например, ELK Stack - Elasticsearch, Logstash, Kibana; или Grafana Loki).
        Примеры задач:
            Структурировать логи (JSON формат).
            Добавлять контекст к логам (ID запроса, ID пользователя).
            Настроить сбор логов с контейнеров (например, с помощью Fluentd или Filebeat).

    Мониторинг (Metrics and Alerting)
        Что это: Сбор метрик производительности (CPU, память, количество запросов, время отклика, ошибки) и настройка оповещений при отклонениях.
        Для чего: Проактивное обнаружение проблем, понимание производительности системы, оценка нагрузки.
        Применение к коду:
            Интегрировать библиотеку для сбора метрик (например, prometheus/client_golang) в Golang приложения.
            Экспонировать метрики на отдельный HTTP-эндпойнт (например, /metrics).
            Настроить сервер мониторинга (например, Prometheus) для сбора этих метрик.
            Создать дашборды (например, в Grafana) для визуализации метрик.
            Настроить систему оповещений (например, Alertmanager) для уведомлений об инцидентах.
        Примеры задач:
            Счетчик обработанных запросов (/users, /users/{id}, /orders, /orders/user/{id}).
            Гистограмма времени ответа для каждого эндпоинта.
            Счетчик ошибок HTTP (4xx, 5xx).
            Метрики использования памяти и CPU контейнеров.

    Конфигурация (Externalized Configuration)
        Что это: Вынесение конфигурационных параметров приложения за пределы кода.
        Для чего: Упрощение управления настройками для разных сред (dev, staging, prod), изменение конфигурации без пересборки приложения.
        Применение к коду: Вместо прямого чтения из кода или жесткого кодирования, использовать переменные окружения (как в примере с USER_SERVICE_URL). Для более сложных систем можно использовать специализированные библиотеки (например, Viper) или системы управления конфигурацией (Consul, etcd).
        Примеры задач:
            Порты, на которых слушают сервисы.
            URL внешних сервисов.
            Параметры подключения к базам данных (когда они будут добавлены).

    Распределенная трассировка (Distributed Tracing)
        Что это: Отслеживание пути запроса через множество микросервисов.
        Для чего: Понимание потока данных, выявление узких мест и причин ошибок в распределенных системах.
        Применение к коду: Интегрировать библиотеки для трассировки (например, OpenTelemetry, Jaeger client) в Golang приложения. При каждом входящем запросе создавать или продолжать трассировку, а при вызове другого сервиса — передавать контекст трассировки.
        Примеры задач:
            Отслеживание запроса от клиента до user-service и/или order-service.
            Отслеживание вызова isUserExists из order-service к user-service.
            Визуализация потока запроса в системе трассировки (например, Jaeger UI).

Этот код предоставляет функциональное ядро, а перечисленные пункты — это направления для применения DevOps практик. Вы можете выбрать один или несколько пунктов и начать их реализовывать, используя соответствующие инструменты. Удачи!








version: '3.8' # Всегда указывайте актуальную версию

services:
  # --- Сервис 1: Основной сервис приложения ---
  main-app: # Пример имени сервиса
    build: # Собираем образ локально
      context: ./main_app/ # Путь к директории с Dockerfile и кодом main-app
      dockerfile: Dockerfile # Имя Dockerfile (по умолчанию Dockerfile)
    container_name: main-app-container # Фиксированное имя контейнера
    restart: unless-stopped # Политика перезапуска: перезапускать, пока не будет остановлен явно
    ports:
      - "80:8080" # Пробрасываем порт 80 хоста на порт 8080 контейнера (где слушает main-app)
    environment:
      # Переменные окружения для конфигурации приложения
      - DB_HOST=db # Имя сервиса базы данных
      - DB_PORT=5432
      - DB_USER=appuser
      - DB_PASSWORD=supersecretpassword # Лучше использовать Docker Secrets или переменные окружения через .env файл
      - LOG_LEVEL=info
      - ANOTHER_SERVICE_URL=http://another-service:9000 # Пример обращения к другому сервису
    volumes: # Монтирование томов (для постоянного хранения данных или логов)
      - ./logs/main-app:/app/logs # Монтируем локальную директорию логов внутрь контейнера
    networks:
      - app-network # Подключаем к нашей внутренней сети
    depends_on: # Зависимости от других сервисов
      - db # main-app зависит от базы данных
      - another-service # main-app зависит от другого сервиса

  # --- Сервис 2: Сервис базы данных (пример) ---
  db:
    image: postgres:14-alpine # Используем готовый образ базы данных
    container_name: db-container
    restart: unless-stopped
    ports:
      - "5432:5432" # Пробрасываем порт для доступа извне (не всегда нужно для продакшена)
    environment:
      # Переменные окружения для PostgreSQL
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: supersecretpassword # Тоже лучше использовать Docker Secrets
      POSTGRES_DB: appdb
    volumes:
      # Сохраняем данные базы данных между перезапусками контейнера
      - db_data:/var/lib/postgresql/data
    networks:
      - app-network

  # --- Сервис 3: Другой микросервис (пример) ---
  another-service:
    build:
      context: ./another_service/
    container_name: another-service-container
    restart: unless-stopped
    ports:
      - "9000:9000" # Например, API gateway или другой вспомогательный сервис
    environment:
      - REDIS_HOST=redis-cache # Пример обращения к другому сервису (Redis)
    networks:
      - app-network
    depends_on:
      - redis-cache

  # --- Сервис 4: Кэш (пример) ---
  redis-cache:
    image: redis:7-alpine # Готовый образ Redis
    container_name: redis-cache-container
    restart: unless-stopped
    ports:
      - "6379:6379" # Проброс порта Redis
    volumes:
      - redis_data:/data # Сохранение данных Redis
    networks:
      - app-network

# --- Объявление пользовательских сетей ---
networks:
  app-network:
    driver: bridge # Используем стандартную bridge-сеть

# --- Объявление пользовательских томов (volumes) ---
volumes:
  db_data: # Именованный том для данных PostgreSQL
  redis_data: # Именованный том для данных Redis